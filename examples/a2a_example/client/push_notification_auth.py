"""
Module to handle push notification authentication for agents.
This module provides classes for both sending and receiving push notifications
and includes methods for generating JWTs, verifying URLs, and handling JWKS endpoints.
"""

import hashlib
import json
import logging
import time
import uuid

from typing import Any

import httpx
import jwt

from jwcrypto import jwk
from jwt import PyJWK, PyJWKClient
from starlette.requests import Request
from starlette.responses import JSONResponse


logger = logging.getLogger(__name__)
AUTH_HEADER_PREFIX = 'Bearer '


class PushNotificationAuth:
    """
    Base class for push notification authentication.
    This class provides methods for generating JWTs and calculating SHA256 hashes
    of request bodies, which are used for signing and verifying push notifications.
    It should be extended by both sender and receiver authentication classes.
    """
    def _calculate_request_body_sha256(self, data: dict[str, Any]):
        """
        Calculates the SHA256 hash of a request body.

        This logic needs to be same for both the agent who
        signs the payload and the client verifier.
        """
        body_str = json.dumps(
            data,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(',', ':'),
        )
        return hashlib.sha256(body_str.encode()).hexdigest()


class PushNotificationSenderAuth(PushNotificationAuth):
    """
    Push Notification Sender Authentication class.
    This class is responsible for generating JWKs, signing payloads with JWTs,
    and sending push notifications to specified URLs.
    It maintains a list of public keys and a private key JWK for signing.
    """
    def __init__(self):
        self.public_keys = []
        self.private_key_jwk: PyJWK = None

    @staticmethod
    async def verify_push_notification_url(url: str) -> bool:
        """
        Verifies the push notification URL by sending a GET request with a validation token.
        This method checks if the URL is valid and can receive push notifications
        by sending a request with a unique validation token and checking the response.

        Args:
            url (str): The URL to verify.

        Returns:
            bool: True if the URL is verified, False otherwise.
        """
        async with httpx.AsyncClient(timeout=10) as client:
            try:
                validation_token = str(uuid.uuid4())
                response = await client.get(
                    url, params={'validationToken': validation_token}
                )
                response.raise_for_status()
                is_verified = response.text == validation_token

                logger.info(
                    f'Verified push-notification URL: {url} => {is_verified}'
                )
                return is_verified
            except Exception as e:
                logger.warning(
                    f'Error during sending push-notification for URL {url}: {e}'
                )

        return False

    def generate_jwk(self):
        """
        Generates a new JWK for signing push notifications.
        This method creates a new RSA key pair, exports the public key,
        and stores the private key as a JWK for signing JWTs.
        """
        key = jwk.JWK.generate(
            kty='RSA', size=2048, kid=str(uuid.uuid4()), use='sig'
        )
        self.public_keys.append(key.export_public(as_dict=True))
        self.private_key_jwk = PyJWK.from_json(key.export_private())

    def handle_jwks_endpoint(self, _request: Request):
        """Allow clients to fetch public keys."""
        return JSONResponse({'keys': self.public_keys})

    def _generate_jwt(self, data: dict[str, Any]):
        """JWT is generated by signing both the request payload SHA digest and time of token generation.

        Payload is signed with private key and it ensures the integrity of payload for client.
        Including iat prevents from replay attack.
        """
        iat = int(time.time())

        return jwt.encode(
            {
                'iat': iat,
                'request_body_sha256': self._calculate_request_body_sha256(
                    data
                ),
            },
            key=self.private_key_jwk,
            headers={'kid': self.private_key_jwk.key_id},
            algorithm='RS256',
        )

    async def send_push_notification(self, url: str, data: dict[str, Any]):
        """
        Sends a push notification to the specified URL with the provided data.
        This method generates a JWT token for the data, sets the Authorization header,
        and sends a POST request to the URL with the data as JSON.

        Args:
            url (str): The URL to send the push notification to.
            data (dict[str, Any]): The data to include in the push notification.
        """
        jwt_token = self._generate_jwt(data)
        headers = {'Authorization': f'Bearer {jwt_token}'}
        async with httpx.AsyncClient(timeout=10) as client:
            try:
                response = await client.post(url, json=data, headers=headers)
                response.raise_for_status()
                logger.info(f'Push-notification sent for URL: {url}')
            except Exception as e:
                logger.warning(
                    f'Error during sending push-notification for URL {url}: {e}'
                )


class PushNotificationReceiverAuth(PushNotificationAuth):
    """
    Push Notification Receiver Authentication class.
    This class is responsible for verifying incoming push notifications
    by checking the JWT token, validating the request body SHA256 hash,
    and ensuring the token is not expired.
    It uses a JWKS client to retrieve public keys for verifying JWTs.
    """
    def __init__(self):
        self.public_keys_jwks = []
        self.jwks_client = None

    async def load_jwks(self, jwks_url: str):
        """
        Loads the JWKS (JSON Web Key Set) from the specified URL.
        This method fetches the JWKS from the given URL and initializes
        the JWKS client for verifying JWT tokens.

        Args:
            jwks_url (str): The URL to fetch the JWKS from.
        """
        self.jwks_client = PyJWKClient(jwks_url)

    async def verify_push_notification(self, request: Request) -> bool:
        """
        Verifies the push notification by checking the Authorization header,
        decoding the JWT token, and validating the request body SHA256 hash.
        This method checks if the Authorization header is present and starts with
        the expected prefix, retrieves the signing key from the JWKS client,
        and decodes the JWT token to verify its integrity and expiration.
        If the verification is successful, it returns True; otherwise, it raises an error.

        Args:
            request (Request): The incoming request containing the push notification data.

        Returns:
            bool: True if the push notification is verified successfully, False otherwise.
        """
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith(AUTH_HEADER_PREFIX):
            print('Invalid authorization header')
            return False

        token = auth_header[len(AUTH_HEADER_PREFIX) :]
        signing_key = self.jwks_client.get_signing_key_from_jwt(token)

        decode_token = jwt.decode(
            token,
            signing_key,
            options={'require': ['iat', 'request_body_sha256']},
            algorithms=['RS256'],
        )

        actual_body_sha256 = self._calculate_request_body_sha256(
            await request.json()
        )
        if actual_body_sha256 != decode_token['request_body_sha256']:
            # Payload signature does not match the digest in signed token.
            raise ValueError('Invalid request body')

        if time.time() - decode_token['iat'] > 60 * 5:
            # Do not allow push-notifications older than 5 minutes.
            # This is to prevent replay attack.
            raise ValueError('Token is expired')

        return True
